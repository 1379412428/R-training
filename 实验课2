#问题1
#3-1
class(1)#浮点型numeric
class(1L)#整型integer
class(1+1i)#复数型complex
#3-2
gender<-factor(c("ab","cd","ab","cd","ef"))#将因子赋值给gender
levels(gender)#显示gender的水平
#3-3
as.numeric("6.283185")#把字符串“6.283185”转换为数字
#3-4
x<-c(1:5)
print(x)#输出x
View(x)#输出x
browseEnv()#网页版输出x
is.numeric(1)#检查是否为浮点型或整型
is.integer(1L)#检查是否为整型
is.double(1)#检查是否为浮点型
#3-5
rm(list=ls())#删除用户工作区中的所有变量
#问题2
#3-1
class(NA)#查找类
class(Inf)#查找类
class(NaN)#查找类
class("")#查找类
typeof(NA)#查找类型
typeof(Inf)#查找类型
typeof(NaN)#查找类型
typeof("")#查找类型
mode(NA)#查找模式
mode(Inf)#查找模式
mode(NaN)#查找模式
mode("")#查找模式
storage.mode(NA)#存储模式
storage.mode(Inf)#存储模式
storage.mode(NaN)#存储模式
storage.mode("")#存储模式
#3-2
gender<-sample(c("dog","cat","dolphin","hamster","goldfish"),100,replace=TRUE)
#随机从“dog”、“cat”、“dolphin”、“hamster”和“goldfish”中以相等的概率生成100个宠物名储存在gender中
print(gender[1:5])#显示所得变量的前5个值
number_dog=0
number_cat=0
number_dolphin=0
number_hamster=0
number_goldfish=0#建立好五个储存宠物数量的变量
n<-1:100
for(i in n){
  if(gender[i]=="dog"){
    number_dog<-number_dog+1
  }
  if(gender[i]=="cat"){
    number_cat<-number_cat+1
  }
  if(gender[i]=="dolphin"){
    number_dolphin<-number_dolphin+1
  }
  if(gender[i]=="hamster"){
    number_hamster<-number_hamster+1
  }
  if(gender[i]=="goldfish"){
    number_goldfish<-number_goldfish+1
  }
}#循环100次，显示五种宠物的数量
ls(pattern="number")#显示五种宠物数量的变量
print(c(number_cat,number_dog,number_dolphin,number_goldfish,number_hamster))#显示五种宠物数量
#3-3
fruit<-c(apple<-1,peach<-2,pear<-3,banana<-4,orange<-5,watermelon<-6,grape<-7)#创建一些以水果命名的变量
ls(pattern="a")#列出用户工作区中所有包含字母“a”的变量
#问题3
#4-1
seq.int(0,1.25,0.25)#创建一个包含值0、0.25、0.5、0.75、1和1.25的向量
#4-2
c(apple<-1,banana<-2,grape<-3)#一种命名向量元素的方式
x<-1:3
names(x)<-c("apple","banana","grape")
x#一种命名向量元素的方式
#4-3
x<-(1:5)^2
x[c(1,5)]#索引第一个和第五个
x[c(-2,-3,-4)]#索引除了第二，三，四个的其他几个
x[c(TRUE,FALSE,FALSE,FALSE,TRUE)]#索引第一个和第五个
names(x)<-c("a","b","c","d","e")
x[c("a","e")]#用命名索引第一个和第五个
#4-4
array_1<-array(
  1:72,
  dim=c(3,4,6),
  dimnames=list(
    c("a","b","c"),
    c("aa","bb","cc","dd"),
    c("aaa","bbb","ccc","ddd","eee","fff")
  )
)#创建一个数组
length(array_1)#显示这个数组的长度
#4-5
a_matrix<-matrix(
  1:16,
  nrow=4,
  byrow=TRUE,
  dimnames=list(
    c("a","b","c","d"),
    c("a","b","c","d")
  ))#创建一个4*4的矩阵
a_matrix
b_matrix<-matrix(
  1:16,
  nrow=4,
  byrow=TRUE,
  dimnames=list(
    c("a","b","c","d"),
    c("a","b","c","d")
  ))#创建一个4*4的矩阵
b_matrix
crossprod(a_matrix,b_matrix)#计算两个矩阵的内积
#问题4
#1)
x<-seq.int(11,50,3)#创建 一个从 11 到 50 ，步长 为3 3 的 向量
x-c(2,3)#再将向量减去向量 c(2,3)
#2)
y<-seq.int(1.1,4,20)#创建 一个从 1.1 到4 4 ，步长为 20 的向量
y*c(4,5,8,9)#再将向量乘向量 c(4,5,8,9)
#3)
a<-c(1,2,4,6)
b<-c(8,0,-1,-4)
a+b
a-b
a*b
a/b#计算 c(1,2,4,6) 和 c(8,0,-1,-4) 的加减乘除后的 结果
#问题5
#4-1
n<-1:50#n赋值为1到50
a=numeric(50)#创建一个空数字向量
for(i in n){
  a[i]=i*(i+1)/2
}#循环将50个三角形数赋值到a中
i=1
n<-1:15
for(i in n){
  letters[i]=a[i]
}#循环将前十五个英文字母赋值为前十五个三角形数
letters[1]
letters[5]
letters[9]
letters[15]
letters[21]#选择命名为元音的三角形数
#4-2
diag_a<-(c(11:1,0,1:11))#创建一个序列11到0到11的向量
diag(diag_a)#将上述向量作为对角线元素创建方阵
#5-2
formals()#使用formals函数时，将返回一个函数参数的成对列表
#5-3
data_frame<-data.frame(
  x=letters[1:5],
  y=1:5,
  z=seq.int(6,10)
)
data_frame
subset(data_frame,y>0,x)#第一种方法，挑选y>0的x列子集
data_frame$x#第二种方法，挑选x列的子集
data_frame[,2]#第三种方法，挑选第二列的子集
data_frame[,"z"]#第四种方法，挑选z列的子集
#5-4
data_frame<-data.frame(
  x=1,
  "..."=3:4,
  "..."=seq.int(5,10),
  check.names=FALSE#列名既非唯一又非有效
)
data_frame
#5-5
a_data_frame<-data.frame(
  x=letters[1:5],
  y=1:5,
  z=seq.int(3,7)
)
b_data_frame<-data.frame(
  x=letters[1:5],
  y=1:5,
  z=seq.int(6,10)
)#创建两个数据框
rbind(a_data_frame,b_data_frame)#将一个数据框追加到另一个之后
#问题7
#5-1
x<-numeric(10)#x向量中储存十个数
m<-1:10#m赋值为1到10
n<-0:9#n赋值为0到9
s<-1#s赋值为1
for(l in m){
  for(i in n){
    if(sqrt(i)==floor(sqrt(i))){#找出平方数
      x[s]=i
      s<-s+1
    }
  }
  n<-n+10
}#两次循环找出平方数
rm(i,l,m,n,s)#清理无用数据
groups<-cut(x,seq.int(0,99,10),include.lowest=TRUE,right=FALSE)#剪切x向量
split(x,groups)#生成列表
#5-2
iris
iris[1:150,-5]#选取iris中的前四列
frame_iris<-data.frame(
  a=iris[1:150,1],
  b=iris[1:150,2],
  c=iris[1:150,3],
  d=iris[1:150,4]
)#创建一个新的数据框，由iris的数值列组成
frame_iris
colMeans(frame_iris[1:150,])
data1<-mean(iris[1:150,1])#计算第一列的平均值
data2<-mean(iris[1:150,2])#计算第二列的平均值
data3<-mean(iris[1:150,3])#计算第三列的平均值
data4<-mean(iris[1:150,4])#计算第四列的平均值
#5-3
beaver1$id<-1#添加id列值为1
beaver2$id<-2#添加id列值为2
beaver1
beaver2
beaver3<-rbind(beaver1,beaver2)#垂直拼接beaver1和beaver2
subset(beaver3,activ==1)#找到所有活跃着的海狸的子集
